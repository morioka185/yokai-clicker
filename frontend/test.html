<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>å¦–æ€ªé€€é­”éŒ² - è‡ªå‹•ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body { background: #1a1a2e; color: #e0e0e0; font-family: monospace; padding: 20px; }
        .test-group { margin: 16px 0; padding: 12px; background: #16213e; border-radius: 8px; }
        .test-group h3 { margin: 0 0 8px; color: #8b5cf6; }
        .pass { color: #22c55e; }
        .fail { color: #ef4444; font-weight: bold; }
        .warn { color: #f59e0b; }
        .test-line { padding: 2px 0; font-size: 13px; }
        #summary { font-size: 18px; margin: 24px 0; padding: 16px; background: #0f3460; border-radius: 8px; }
        .detail { color: #9e9e9e; font-size: 11px; margin-left: 20px; }
    </style>
</head>
<body>
    <!-- æœ€å°é™ã®DOMè¦ç´ ï¼ˆãƒ†ã‚¹ãƒˆã«å¿…è¦ãªã‚‚ã®ï¼‰ -->
    <div id="app" style="display:none">
        <div id="title-screen" class="screen active"></div>
        <div id="village-screen" class="screen"></div>
        <div id="dungeon-select-screen" class="screen"></div>
        <div id="battle-screen" class="screen">
            <div id="dungeon-name"></div>
            <div id="floor-display"></div>
            <div id="player-hp-bar"></div>
            <div id="player-hp-text"></div>
            <div id="player-mp-bar"></div>
            <div id="player-mp-text"></div>
            <div id="player-exp-bar"></div>
            <div id="player-exp-text"></div>
            <div id="player-level"></div>
            <div id="gold-display"></div>
            <div id="spirit-stone-display"></div>
            <div id="player-stats"></div>
            <div id="current-weapon-info"></div>
            <div id="shikigami-party"></div>
            <div id="enemy-area">
                <div id="enemy-wave"></div>
                <div id="click-area"></div>
                <div id="damage-numbers"></div>
            </div>
            <div id="weapon-ui"></div>
            <div id="kill-count"></div>
            <div id="kill-required"></div>
            <div id="btn-auto-toggle"></div>
            <div id="tab-skills"></div>
            <div id="tab-equipment"></div>
            <div id="tab-items"></div>
            <div id="tab-log"></div>
            <div id="floor-transition">
                <div id="floor-transition-text"></div>
                <div id="floor-transition-subtitle"></div>
            </div>
            <div id="player-hit-overlay"></div>
            <div id="battle-right-panel"></div>
            <div id="mobile-panel-backdrop"></div>
        </div>
        <div id="levelup-modal" class="modal">
            <div id="levelup-hint"></div>
            <div id="levelup-choices"></div>
        </div>
        <div id="drop-modal" class="modal">
            <div id="drop-list"></div>
        </div>
        <div id="result-modal" class="modal">
            <div id="result-title"></div>
            <div id="result-details"></div>
        </div>
        <div id="smithy-screen" class="screen"><div id="smithy-content"></div></div>
        <div id="inventory-screen" class="screen"><div id="inventory-content"></div></div>
        <div id="shikigami-screen" class="screen"><div id="shikigami-content"></div></div>
        <div id="gacha-screen" class="screen"><div id="gacha-content"></div></div>
        <div id="arena-screen" class="screen"><div id="arena-content"></div></div>
        <div id="encyclopedia-screen" class="screen">
            <div id="enc-summary"></div>
            <div id="enc-content"></div>
        </div>
        <div id="settings-screen" class="screen"><div id="settings-content"></div></div>
        <div id="notification-container"></div>
        <div id="title-particles"></div>
        <div id="village-player-summary"></div>
        <div id="dungeon-list"></div>
        <div id="gacha-spirit-result" class="gacha-result"></div>
        <div id="gacha-gold-result" class="gacha-result"></div>
        <div id="arena-opponents"></div>
        <div id="arena-battle-result"></div>
        <div id="save-io-area"></div>
    </div>

    <h1>å¦–æ€ªé€€é­”éŒ² - è‡ªå‹•ãƒ†ã‚¹ãƒˆçµæœ</h1>
    <div id="summary"></div>
    <div id="results"></div>

    <!-- ã‚²ãƒ¼ãƒ ã‚¹ã‚¯ãƒªãƒ—ãƒˆèª­ã¿è¾¼ã¿ -->
    <script src="js/data/enemies.js"></script>
    <script src="js/data/equipment.js"></script>
    <script src="js/data/skills.js"></script>
    <script src="js/data/shikigami.js"></script>
    <script src="js/data/dungeons.js"></script>
    <script src="js/sound.js"></script>
    <script src="js/state.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/combat.js"></script>
    <script src="js/weapons.js"></script>
    <script src="js/dungeon.js"></script>
    <script src="js/equipment.js"></script>
    <script src="js/shikigami.js"></script>
    <script src="js/smithy.js"></script>
    <script src="js/gacha.js"></script>
    <script src="js/arena.js"></script>
    <script src="js/encyclopedia.js"></script>
    <script src="js/save.js"></script>
    <script src="js/ui.js"></script>

    <script>
    // ===== ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ =====
    const TestRunner = {
        results: [],
        currentGroup: '',

        group(name) {
            this.currentGroup = name;
        },

        assert(description, condition, detail = '') {
            this.results.push({
                group: this.currentGroup,
                description,
                passed: !!condition,
                detail
            });
        },

        assertEqual(description, actual, expected, detail = '') {
            const passed = actual === expected;
            this.results.push({
                group: this.currentGroup,
                description,
                passed,
                detail: passed ? detail : `æœŸå¾…å€¤: ${JSON.stringify(expected)}, å®Ÿéš›: ${JSON.stringify(actual)}. ${detail}`
            });
        },

        assertRange(description, value, min, max) {
            const passed = value >= min && value <= max;
            this.results.push({
                group: this.currentGroup,
                description,
                passed,
                detail: passed ? '' : `å€¤ ${value} ãŒç¯„å›² [${min}, ${max}] ã®å¤–`
            });
        },

        render() {
            const groups = {};
            for (const r of this.results) {
                if (!groups[r.group]) groups[r.group] = [];
                groups[r.group].push(r);
            }

            const totalPass = this.results.filter(r => r.passed).length;
            const totalFail = this.results.filter(r => !r.passed).length;
            const total = this.results.length;

            document.getElementById('summary').innerHTML = `
                <span class="${totalFail === 0 ? 'pass' : 'fail'}">
                    ãƒ†ã‚¹ãƒˆçµæœ: ${totalPass}/${total} åˆæ ¼ (${totalFail} ä¸åˆæ ¼)
                </span>
            `;

            let html = '';
            for (const [groupName, tests] of Object.entries(groups)) {
                const groupPass = tests.filter(t => t.passed).length;
                const groupTotal = tests.length;
                const allPassed = groupPass === groupTotal;

                html += `<div class="test-group">
                    <h3>${allPassed ? 'âœ…' : 'âŒ'} ${groupName} (${groupPass}/${groupTotal})</h3>`;
                for (const t of tests) {
                    html += `<div class="test-line ${t.passed ? 'pass' : 'fail'}">
                        ${t.passed ? '  âœ“' : '  âœ—'} ${t.description}
                    </div>`;
                    if (!t.passed && t.detail) {
                        html += `<div class="detail">${t.detail}</div>`;
                    }
                }
                html += '</div>';
            }

            document.getElementById('results').innerHTML = html;
        }
    };

    // ===== çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼ =====
    function resetGameState() {
        GameState.player = {
            name: 'é€€é­”å¸«', gold: 500, spiritStones: 50, satoriPoints: 0,
            totalClears: 0, totalDefeats: 0, highestFloor: {}, clearedDungeons: {},
            firstClearBonuses: {},
            satoriBonuses: { atk: 0, def: 0, hp: 0, critRate: 0, goldBonus: 0, expBonus: 0, dropRate: 0 }
        };
        GameState.inventory = { equipment: [], materials: {}, maxEquipSlots: 50 };
        GameState.equipped = { weapon: null, head: null, body: null, hands: null, feet: null, charm: null };
        GameState.shikigami = { owned: {}, party: [null, null, null] };
        GameState.gachaPity = { spirit: 0, gold: 0 };
        GameState.dungeon = {
            active: false, currentDungeon: null, currentFloor: 1,
            playerLevel: 1, playerExp: 0, playerHP: 100, playerMaxHP: 100,
            playerMP: 50, playerMaxMP: 50, playerATK: 10, playerDEF: 5,
            playerCritRate: 5, playerCritDmg: 150,
            acquiredSkills: {}, lootedEquipment: [], lootedMaterials: {},
            lootedGold: 0, lootedSpiritStones: 0,
            currentEnemies: [], enemyAttackTimers: {}, killCount: 0, killsRequired: 5,
            floorCleared: false, autoAttack: false, autoAttackTimer: null,
            weaponState: {}, buffs: [], enemyDebuffs: [], shikigamiTimers: [],
            reviveUsed: false, pendingLevelUps: 0
        };
        GameState.arena = { rank: 1000, wins: 0, losses: 0, medals: 0 };
        GameState.encyclopedia = { discoveredEnemies: {}, achievements: {}, craftCount: 0 };
        GameState.settings = { soundEnabled: false, autoSave: true, damageNumbers: true, shakeScreen: true };
        GameState.battleLog = [];
    }

    // ===== ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ =====
    function runAllTests() {
        resetGameState();

        // ==========================================
        // 1. ãƒ‡ãƒ¼ã‚¿å®šç¾©ã®å®Œå…¨æ€§ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('1. ãƒ‡ãƒ¼ã‚¿å®šç¾©ã®å®Œå…¨æ€§');

        // æ•µãƒ‡ãƒ¼ã‚¿
        const enemyCount = Object.keys(ENEMIES).length;
        TestRunner.assert(`æ•µãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹ (${enemyCount}ç¨®)`, enemyCount > 0);
        for (const [id, enemy] of Object.entries(ENEMIES)) {
            TestRunner.assert(`æ•µ[${id}] - å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®Œå‚™`,
                enemy.id && enemy.name && enemy.emoji &&
                enemy.baseHP > 0 && enemy.baseATK >= 0 && enemy.baseDEF >= 0 &&
                enemy.expReward > 0 && enemy.goldReward > 0,
                `HP:${enemy.baseHP} ATK:${enemy.baseATK} DEF:${enemy.baseDEF}`
            );
        }

        // ãƒœã‚¹ãƒ‡ãƒ¼ã‚¿
        const bossCount = Object.keys(BOSSES).length;
        TestRunner.assert(`ãƒœã‚¹ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹ (${bossCount}ä½“)`, bossCount > 0);
        for (const [id, boss] of Object.entries(BOSSES)) {
            TestRunner.assert(`ãƒœã‚¹[${id}] - isBossãƒ•ãƒ©ã‚°ãŒtrue`, boss.isBoss === true);
            TestRunner.assert(`ãƒœã‚¹[${id}] - éœŠçŸ³å ±é…¬ãŒã‚ã‚‹`, boss.spiritStoneReward > 0);
        }

        // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿
        const dungeonCount = Object.keys(DUNGEONS).length;
        TestRunner.assert(`ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹ (${dungeonCount}å€‹)`, dungeonCount > 0);
        for (const [id, dungeon] of Object.entries(DUNGEONS)) {
            TestRunner.assert(`ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³[${id}] - æ•µãƒ†ãƒ¼ãƒ–ãƒ«ãŒå­˜åœ¨`,
                !!DUNGEON_ENEMIES[dungeon.enemyTable],
                `enemyTable: ${dungeon.enemyTable}`
            );
            // ãƒœã‚¹éšã®ãƒœã‚¹ãŒå­˜åœ¨ã™ã‚‹ã‹
            if (dungeon.bossFloors) {
                for (const [floor, bossId] of Object.entries(dungeon.bossFloors)) {
                    TestRunner.assert(`ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³[${id}] B${floor}F ãƒœã‚¹[${bossId}]ãŒå­˜åœ¨`,
                        !!BOSSES[bossId]
                    );
                }
            }
        }

        // æ•µãƒ†ãƒ¼ãƒ–ãƒ«ã®å‚ç…§æ•´åˆæ€§
        for (const [tableId, enemies] of Object.entries(DUNGEON_ENEMIES)) {
            for (const enemyId of enemies) {
                TestRunner.assert(`æ•µãƒ†ãƒ¼ãƒ–ãƒ«[${tableId}] - æ•µ[${enemyId}]ãŒå­˜åœ¨`,
                    !!ENEMIES[enemyId]
                );
            }
        }

        // ã‚¹ã‚­ãƒ«ãƒ‡ãƒ¼ã‚¿
        const skillCount = Object.keys(LEVELUP_SKILLS).length;
        TestRunner.assert(`ã‚¹ã‚­ãƒ«ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹ (${skillCount}å€‹)`, skillCount > 0);
        for (const [id, skill] of Object.entries(LEVELUP_SKILLS)) {
            TestRunner.assert(`ã‚¹ã‚­ãƒ«[${id}] - ã‚«ãƒ†ã‚´ãƒªãŒæ­£ã—ã„`,
                ['budo', 'onmyo', 'jintsuu'].includes(skill.category),
                `category: ${skill.category}`
            );
            TestRunner.assert(`ã‚¹ã‚­ãƒ«[${id}] - effectã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜åœ¨`,
                typeof skill.effect === 'object'
            );
        }

        // å¼ç¥ãƒ‡ãƒ¼ã‚¿
        const shikiCount = Object.keys(SHIKIGAMI_DATA).length;
        TestRunner.assert(`å¼ç¥ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹ (${shikiCount}ä½“)`, shikiCount > 0);
        for (const [id, shiki] of Object.entries(SHIKIGAMI_DATA)) {
            TestRunner.assert(`å¼ç¥[${id}] - å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®Œå‚™`,
                shiki.stars >= 1 && shiki.stars <= 5 && shiki.skill && shiki.passive,
                `stars: ${shiki.stars}`
            );
            if (shiki.obtainMethod === 'boss') {
                TestRunner.assert(`å¼ç¥[${id}] - ãƒœã‚¹[${shiki.obtainBoss}]ãŒå­˜åœ¨`,
                    !!BOSSES[shiki.obtainBoss]
                );
            }
        }

        // ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿
        const enchantCount = Object.keys(ENCHANT_POOL).length;
        TestRunner.assert(`ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹ (${enchantCount}å€‹)`, enchantCount > 0);
        for (const [id, ench] of Object.entries(ENCHANT_POOL)) {
            TestRunner.assert(`ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆ[${id}] - min <= max`, ench.min <= ench.max);
        }

        // ç´ æãƒ‡ãƒ¼ã‚¿
        const matCount = Object.keys(MATERIALS).length;
        TestRunner.assert(`ç´ æãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹ (${matCount}å€‹)`, matCount > 0);

        // ãƒ‰ãƒ­ãƒƒãƒ—ç´ æã®å‚ç…§æ•´åˆæ€§
        for (const [id, enemy] of Object.entries(ENEMIES)) {
            if (enemy.drops) {
                for (const drop of enemy.drops) {
                    TestRunner.assert(`æ•µ[${id}] ãƒ‰ãƒ­ãƒƒãƒ—ç´ æ[${drop.id}]ãŒå®šç¾©æ¸ˆã¿`,
                        !!MATERIALS[drop.id]
                    );
                }
            }
        }
        for (const [id, boss] of Object.entries(BOSSES)) {
            if (boss.drops) {
                for (const drop of boss.drops) {
                    TestRunner.assert(`ãƒœã‚¹[${id}] ãƒ‰ãƒ­ãƒƒãƒ—ç´ æ[${drop.id}]ãŒå®šç¾©æ¸ˆã¿`,
                        !!MATERIALS[drop.id]
                    );
                }
            }
        }

        // ã‚¯ãƒ©ãƒ•ãƒˆãƒ¬ã‚·ãƒ”ã®ç´ ææ•´åˆæ€§
        for (const [id, recipe] of Object.entries(CRAFT_RECIPES)) {
            for (const [matId, count] of Object.entries(recipe.materials)) {
                TestRunner.assert(`ãƒ¬ã‚·ãƒ”[${id}] ç´ æ[${matId}]ãŒå®šç¾©æ¸ˆã¿`,
                    !!MATERIALS[matId]
                );
            }
        }

        // ==========================================
        // 2. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('2. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°');

        // randomInt
        for (let i = 0; i < 100; i++) {
            const val = randomInt(1, 10);
            if (val < 1 || val > 10) {
                TestRunner.assert('randomInt(1,10) ãŒç¯„å›²å†…', false, `å€¤: ${val}`);
                break;
            }
        }
        TestRunner.assert('randomInt(1,10) ãŒç¯„å›²å†… (100å›ãƒ†ã‚¹ãƒˆ)', true);

        // randomFloat
        for (let i = 0; i < 100; i++) {
            const val = randomFloat(0.5, 1.5);
            if (val < 0.5 || val > 1.5) {
                TestRunner.assert('randomFloat(0.5,1.5) ãŒç¯„å›²å†…', false, `å€¤: ${val}`);
                break;
            }
        }
        TestRunner.assert('randomFloat(0.5,1.5) ãŒç¯„å›²å†… (100å›ãƒ†ã‚¹ãƒˆ)', true);

        // formatNumber
        TestRunner.assertEqual('formatNumber(999)', formatNumber(999), '999');
        TestRunner.assertEqual('formatNumber(10000)', formatNumber(10000), '1.0ä¸‡');
        TestRunner.assertEqual('formatNumber(100000000)', formatNumber(100000000), '1.0å„„');

        // å±æ€§ç›¸æ€§
        TestRunner.assertEqual('ç«â†’æœ¨ ã¯æœ‰åˆ© (1.5)', getElementMultiplier('fire', 'wood'), 1.5);
        TestRunner.assertEqual('æœ¨â†’ç« ã¯ä¸åˆ© (0.7)', getElementMultiplier('wood', 'fire'), 0.7);
        TestRunner.assertEqual('ç«â†’æ°´ ã¯ä¸åˆ© (0.7)', getElementMultiplier('fire', 'water'), 0.7);
        TestRunner.assertEqual('æ°´â†’ç« ã¯æœ‰åˆ© (1.5)', getElementMultiplier('water', 'fire'), 1.5);
        TestRunner.assertEqual('ç«â†’ç« ã¯ç­‰å€ (1.0)', getElementMultiplier('fire', 'fire'), 1.0);
        TestRunner.assertEqual('nullâ†’fire ã¯ç­‰å€ (1.0)', getElementMultiplier(null, 'fire'), 1.0);

        // å±æ€§å
        TestRunner.assertEqual('getElementName("fire")', getElementName('fire'), 'ç«');
        TestRunner.assertEqual('getElementName("water")', getElementName('water'), 'æ°´');

        // ãƒ¬ã‚¢ãƒªãƒ†ã‚£
        TestRunner.assertEqual('getRarityName("common")', getRarityName('common'), 'å‡¡');
        TestRunner.assertEqual('getRarityName("legendary")', getRarityName('legendary'), 'ä¼èª¬');

        // UIDç”Ÿæˆ
        const uid1 = generateUID();
        const uid2 = generateUID();
        TestRunner.assert('generateUID() ã¯ãƒ¦ãƒ‹ãƒ¼ã‚¯', uid1 !== uid2);

        // çµŒé¨“å€¤ãƒ†ãƒ¼ãƒ–ãƒ«
        const exp1 = getExpToNextLevel(1);
        const exp5 = getExpToNextLevel(5);
        const exp10 = getExpToNextLevel(10);
        TestRunner.assert('çµŒé¨“å€¤ãƒ†ãƒ¼ãƒ–ãƒ«: Lv1 < Lv5 < Lv10', exp1 < exp5 && exp5 < exp10, `Lv1:${exp1} Lv5:${exp5} Lv10:${exp10}`);

        // ãƒ•ãƒ­ã‚¢ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
        const scale1 = getFloorScaling('forest', 1);
        const scale10 = getFloorScaling('forest', 10);
        TestRunner.assert('ãƒ•ãƒ­ã‚¢ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°: 1F < 10F', scale1 < scale10, `1F:${scale1} 10F:${scale10}`);
        const scaleDark = getFloorScaling('dark', 1);
        TestRunner.assert('dark ã®åŸºç¤å€ç‡ > forest', scaleDark > scale1);

        // weightedRandom
        const weights = { a: 100, b: 0 };
        TestRunner.assertEqual('weightedRandom({a:100, b:0})', weightedRandom(weights), 'a');

        // starsDisplay
        TestRunner.assertEqual('starsDisplay(3)', starsDisplay(3), 'â˜…â˜…â˜…â˜†â˜†');
        TestRunner.assertEqual('starsDisplay(5)', starsDisplay(5), 'â˜…â˜…â˜…â˜…â˜…');

        // ==========================================
        // 3. ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¨ˆç®—ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('3. ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¨ˆç®—');

        resetGameState();
        const baseStats = calculatePlayerStats();
        TestRunner.assert('åŸºç¤ATK > 0', baseStats.atk > 0, `ATK: ${baseStats.atk}`);
        TestRunner.assert('åŸºç¤DEF > 0', baseStats.def > 0, `DEF: ${baseStats.def}`);
        TestRunner.assert('åŸºç¤maxHP > 0', baseStats.maxHP > 0, `maxHP: ${baseStats.maxHP}`);
        TestRunner.assert('åŸºç¤maxMP > 0', baseStats.maxMP > 0, `maxMP: ${baseStats.maxMP}`);
        TestRunner.assertEqual('åŸºç¤weaponType = fist', baseStats.weaponType, 'fist');

        // æ­¦å™¨è£…å‚™æ™‚
        GameState.equipped.weapon = {
            uid: 'test1', name: 'ãƒ†ã‚¹ãƒˆåˆ€', slot: 'weapon', weaponType: 'katana',
            rarity: 'rare', atk: 100, def: 0, hp: 0, element: 'fire',
            enchants: [], enhanceLevel: 0, fixedEffect: null
        };
        const weaponStats = calculatePlayerStats();
        TestRunner.assert('æ­¦å™¨è£…å‚™ã§ATKãŒå¢—åŠ ', weaponStats.atk > baseStats.atk, `ç„¡ã—:${baseStats.atk} æœ‰ã‚Š:${weaponStats.atk}`);
        TestRunner.assertEqual('æ­¦å™¨è£…å‚™ã§weaponTypeå¤‰æ›´', weaponStats.weaponType, 'katana');
        TestRunner.assertEqual('æ­¦å™¨å±æ€§ãŒåæ˜ ', weaponStats.weaponElement, 'fire');

        // é˜²å…·è£…å‚™æ™‚
        GameState.equipped.body = {
            uid: 'test2', name: 'ãƒ†ã‚¹ãƒˆé§', slot: 'body',
            rarity: 'rare', atk: 0, def: 50, hp: 100, element: null,
            enchants: [], enhanceLevel: 0, fixedEffect: null
        };
        const armorStats = calculatePlayerStats();
        TestRunner.assert('é˜²å…·ã§DEFãŒå¢—åŠ ', armorStats.def > weaponStats.def);
        TestRunner.assert('é˜²å…·ã§maxHPãŒå¢—åŠ ', armorStats.maxHP > weaponStats.maxHP);

        // ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆåŠ¹æœ
        GameState.equipped.weapon.enchants = [
            { id: 'goriki', name: 'å‰›åŠ›', value: 20, display: 'ATK +20%' },
            { id: 'kaishin', name: 'ä¼šå¿ƒ', value: 10, display: 'ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡ +10%' }
        ];
        const enchStats = calculatePlayerStats();
        TestRunner.assert('ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆã§ATK%å¢—åŠ ', enchStats.atkPercent >= 20);
        TestRunner.assert('ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆã§ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡å¢—åŠ ', enchStats.critRate > armorStats.critRate);

        // ã‚¹ã‚­ãƒ«åŠ¹æœ
        GameState.dungeon.acquiredSkills = { 'budo_goriki': 2 };
        const skillStats = calculatePlayerStats();
        TestRunner.assert('ã‚¹ã‚­ãƒ«ã§clickDmgPercentå¢—åŠ ', skillStats.clickDmgPercent >= 100, `clickDmgPercent: ${skillStats.clickDmgPercent}`);

        // å¼ç¥ãƒ‘ãƒƒã‚·ãƒ–
        GameState.shikigami.owned['hinotama_shiki'] = { level: 1, exp: 0, affection: 0 };
        GameState.shikigami.party = ['hinotama_shiki', null, null];
        const shikiStats = calculatePlayerStats();
        TestRunner.assert('å¼ç¥ãƒ‘ãƒƒã‚·ãƒ–ã§ç«å±æ€§ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ ', shikiStats.elemDmg.fire > 0);

        // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ™‚ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¢—åŠ 
        resetGameState();
        GameState.dungeon.playerLevel = 10;
        const lv10Stats = calculatePlayerStats();
        const lv1Stats = (() => { GameState.dungeon.playerLevel = 1; return calculatePlayerStats(); })();
        TestRunner.assert('Lv10 > Lv1 ã®ATK', lv10Stats.atk > lv1Stats.atk);
        TestRunner.assert('Lv10 > Lv1 ã®DEF', lv10Stats.def > lv1Stats.def);
        TestRunner.assert('Lv10 > Lv1 ã®maxHP', lv10Stats.maxHP > lv1Stats.maxHP);

        // ==========================================
        // 4. æˆ¦é—˜ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('4. æˆ¦é—˜ã‚·ã‚¹ãƒ†ãƒ ');

        resetGameState();
        GameState.dungeon.active = true;
        GameState.dungeon.currentDungeon = 'forest';
        GameState.dungeon.currentFloor = 1;

        // æ•µã‚¹ãƒãƒ¼ãƒ³
        Combat.spawnEnemyWave();
        const alive = Combat.getAliveEnemies();
        TestRunner.assert('æ•µã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒãƒ¼ãƒ³æˆåŠŸ', alive.length > 0, `æ•µæ•°: ${alive.length}`);
        TestRunner.assert('æ•µã«HPãŒã‚ã‚‹', alive[0].hp > 0);
        TestRunner.assert('æ•µã«positionãŒã‚ã‚‹', alive[0].position !== undefined);

        // ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
        const stats = calculatePlayerStats();
        const testEnemy = alive[0];
        const dmgResult = Combat.calculateDamage(stats, testEnemy, 1.0);
        TestRunner.assert('ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®— > 0', dmgResult.damage > 0, `damage: ${dmgResult.damage}`);

        // ã‚¯ãƒªãƒƒã‚¯æ”»æ’ƒ
        const hpBefore = testEnemy.hp;
        Combat.performClick(1.0, [testEnemy]);
        TestRunner.assert('ã‚¯ãƒªãƒƒã‚¯æ”»æ’ƒã§æ•µHPãŒæ¸›å°‘', testEnemy.hp < hpBefore, `å‰:${hpBefore} å¾Œ:${testEnemy.hp}`);

        // æ•µæ’ƒç ´ãƒ†ã‚¹ãƒˆ
        resetGameState();
        GameState.dungeon.active = true;
        GameState.dungeon.currentDungeon = 'forest';
        const weakEnemy = {
            id: 'test_enemy', name: 'ãƒ†ã‚¹ãƒˆæ•µ', emoji: 'ğŸ‘»',
            element: null, hp: 1, maxHP: 1, atk: 1, def: 0,
            expReward: 100, goldReward: 50, position: 1,
            drops: []
        };
        GameState.dungeon.currentEnemies = [weakEnemy];
        GameState.dungeon.enemyAttackTimers = { 1: 0 };
        const expBefore = GameState.dungeon.playerExp;
        const goldBefore = GameState.dungeon.lootedGold;
        Combat.applyDamageToEnemy(10, false, weakEnemy);
        TestRunner.assert('æ•µæ’ƒç ´å¾Œã«EXPãŒå¢—åŠ ', GameState.dungeon.playerExp > expBefore);
        TestRunner.assert('æ•µæ’ƒç ´å¾Œã«GoldãŒå¢—åŠ ', GameState.dungeon.lootedGold > goldBefore);
        TestRunner.assertEqual('æ•µã®HP = 0', weakEnemy.hp, 0);

        // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
        resetGameState();
        GameState.dungeon.active = true;
        GameState.dungeon.playerLevel = 1;
        GameState.dungeon.playerExp = getExpToNextLevel(1) + 1;
        Combat.checkLevelUp();
        TestRunner.assert('ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãŒç™ºç”Ÿ', GameState.dungeon.playerLevel > 1, `Lv: ${GameState.dungeon.playerLevel}`);

        // å›å¾©ãƒ†ã‚¹ãƒˆ
        resetGameState();
        GameState.dungeon.active = true;
        GameState.dungeon.playerHP = 50;
        GameState.dungeon.playerMaxHP = 100;
        Combat.healPlayer(30);
        TestRunner.assertEqual('å›å¾©å¾Œã®HP', GameState.dungeon.playerHP, 80);

        // å›å¾©ä¸Šé™ãƒ†ã‚¹ãƒˆ
        Combat.healPlayer(1000);
        TestRunner.assertEqual('HPã¯æœ€å¤§HPã‚’è¶…ãˆãªã„', GameState.dungeon.playerHP, GameState.dungeon.playerMaxHP);

        // è¢«ãƒ€ãƒ¡ãƒ†ã‚¹ãƒˆ
        resetGameState();
        GameState.dungeon.active = true;
        GameState.dungeon.playerHP = 100;
        GameState.dungeon.playerMaxHP = 100;
        const attackEnemy = { name: 'æ”»æ’ƒæ•µ', atk: 50, element: null, hp: 100, position: 1 };
        Combat.enemyAttackFrom(attackEnemy);
        TestRunner.assert('æ•µæ”»æ’ƒã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼HPãŒæ¸›å°‘', GameState.dungeon.playerHP < 100);

        // ç„¡æ•µãƒãƒ•ãƒ†ã‚¹ãƒˆ
        resetGameState();
        GameState.dungeon.active = true;
        GameState.dungeon.playerHP = 100;
        GameState.dungeon.playerMaxHP = 100;
        GameState.dungeon.buffs = [{ type: 'invincible', remaining: 10 }];
        const hpBeforeBuff = GameState.dungeon.playerHP;
        Combat.enemyAttackFrom({ name: 'ãƒ†ã‚¹ãƒˆ', atk: 999, element: null, hp: 100, position: 1 });
        TestRunner.assertEqual('ç„¡æ•µãƒãƒ•ä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸0', GameState.dungeon.playerHP, hpBeforeBuff);

        // å¾©æ´»ãƒ†ã‚¹ãƒˆ
        resetGameState();
        GameState.dungeon.active = true;
        GameState.dungeon.playerHP = 1;
        GameState.dungeon.playerMaxHP = 100;
        GameState.dungeon.acquiredSkills = { 'jintsuu_fukkatsu': 1 };
        GameState.dungeon.reviveUsed = false;
        Combat.enemyAttackFrom({ name: 'ãƒ†ã‚¹ãƒˆ', atk: 9999, def: 0, element: null, hp: 100, position: 1 });
        TestRunner.assert('å¾©æ´»ã‚¹ã‚­ãƒ«ãŒç™ºå‹•', GameState.dungeon.playerHP > 0, `HP: ${GameState.dungeon.playerHP}`);
        TestRunner.assert('å¾©æ´»ãƒ•ãƒ©ã‚°ãŒON', GameState.dungeon.reviveUsed === true);

        // ãƒœã‚¹ã‚¹ãƒãƒ¼ãƒ³
        resetGameState();
        GameState.dungeon.active = true;
        GameState.dungeon.currentDungeon = 'forest';
        GameState.dungeon.currentFloor = 10;
        Combat.spawnBoss('boss_yamawarashi');
        const bossAlive = Combat.getAliveEnemies();
        TestRunner.assert('ãƒœã‚¹ãŒã‚¹ãƒãƒ¼ãƒ³ã—ãŸ', bossAlive.length === 1);
        TestRunner.assert('ãƒœã‚¹ã®isBossãƒ•ãƒ©ã‚°', bossAlive[0].isBoss === true);
        TestRunner.assert('ãƒœã‚¹ã®position = 1 (ä¸­å¤®)', bossAlive[0].position === 1);

        // ==========================================
        // 5. ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('5. ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ');

        // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³é–‹å§‹
        resetGameState();
        Dungeon.startDungeon('forest');
        TestRunner.assert('ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ãŒactive', GameState.dungeon.active === true);
        TestRunner.assertEqual('currentDungeon = forest', GameState.dungeon.currentDungeon, 'forest');
        TestRunner.assertEqual('currentFloor = 1', GameState.dungeon.currentFloor, 1);
        TestRunner.assert('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼HPãŒè¨­å®šæ¸ˆã¿', GameState.dungeon.playerHP > 0);
        TestRunner.assert('æ•µãŒã‚¹ãƒãƒ¼ãƒ³æ¸ˆã¿', GameState.dungeon.currentEnemies.length > 0);
        Dungeon.stopGameLoop();

        // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¡ä»¶
        TestRunner.assert('åˆå¿ƒè€…ã®æ£®ã¯ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¸ˆã¿', Dungeon.isDungeonUnlocked('forest'));
        TestRunner.assert('å¦–ç‹ã®ç¤¾ã¯æœªã‚¢ãƒ³ãƒ­ãƒƒã‚¯', !Dungeon.isDungeonUnlocked('shrine'));
        GameState.player.clearedDungeons['forest'] = true;
        TestRunner.assert('æ£®ã‚¯ãƒªã‚¢å¾Œã«ç¤¾ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯', Dungeon.isDungeonUnlocked('shrine'));

        // å ±é…¬é©ç”¨ãƒ†ã‚¹ãƒˆ
        resetGameState();
        GameState.dungeon.lootedGold = 1000;
        GameState.dungeon.lootedSpiritStones = 50;
        GameState.dungeon.lootedMaterials = { 'wood_shard': 10 };
        GameState.dungeon.lootedEquipment = [
            { uid: 'test', name: 'ãƒ†ã‚¹ãƒˆæ­¦å™¨', slot: 'weapon', rarity: 'common', enchants: [] }
        ];

        const goldBefore2 = GameState.player.gold;
        Dungeon.applyRewards(true);
        TestRunner.assertEqual('æˆåŠŸæ™‚ã‚´ãƒ¼ãƒ«ãƒ‰å…¨é¡', GameState.player.gold, goldBefore2 + 1000);
        TestRunner.assertEqual('æˆåŠŸæ™‚éœŠçŸ³å…¨é¡', GameState.player.spiritStones, 100); // 50åˆæœŸ + 50
        TestRunner.assertEqual('æˆåŠŸæ™‚ç´ æå…¨æ•°', GameState.inventory.materials['wood_shard'], 10);
        TestRunner.assertEqual('æˆåŠŸæ™‚è£…å‚™ä¿æŒ', GameState.inventory.equipment.length, 1);

        // å¤±æ•—æ™‚ã®å ±é…¬åŠæ¸›
        resetGameState();
        GameState.dungeon.lootedGold = 1000;
        GameState.dungeon.lootedSpiritStones = 50;
        GameState.dungeon.lootedEquipment = [
            { uid: 'test', name: 'ãƒ†ã‚¹ãƒˆ', slot: 'weapon', rarity: 'common', enchants: [] }
        ];
        const goldBefore3 = GameState.player.gold;
        Dungeon.applyRewards(false);
        TestRunner.assertEqual('å¤±æ•—æ™‚ã‚´ãƒ¼ãƒ«ãƒ‰åŠæ¸›', GameState.player.gold, goldBefore3 + 500);
        TestRunner.assertEqual('å¤±æ•—æ™‚è£…å‚™æ¶ˆå¤±', GameState.inventory.equipment.length, 0);

        // ==========================================
        // 6. è£…å‚™ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('6. è£…å‚™ã‚·ã‚¹ãƒ†ãƒ ');

        resetGameState();

        // ãƒœã‚¹æ­¦å™¨ç”Ÿæˆ
        const bossWeapon = Equipment.generateBossWeapon({
            baseName: 'ãƒ†ã‚¹ãƒˆæ­¦å™¨', slot: 'weapon', weaponType: 'katana',
            baseATK: 100, element: 'fire', chance: 1.0,
            enchantSlots: { min: 2, max: 3 }
        }, 10);
        TestRunner.assert('ãƒœã‚¹æ­¦å™¨ãŒç”Ÿæˆã•ã‚ŒãŸ', !!bossWeapon);
        TestRunner.assert('ãƒœã‚¹æ­¦å™¨ã«UID', !!bossWeapon.uid);
        TestRunner.assertEqual('ãƒœã‚¹æ­¦å™¨ã®ã‚¹ãƒ­ãƒƒãƒˆ', bossWeapon.slot, 'weapon');
        TestRunner.assertEqual('ãƒœã‚¹æ­¦å™¨ã®ã‚¿ã‚¤ãƒ—', bossWeapon.weaponType, 'katana');
        TestRunner.assert('ãƒœã‚¹æ­¦å™¨ã®ATK â‰ˆ 100', bossWeapon.atk >= 90 && bossWeapon.atk <= 110);
        TestRunner.assertRange('ãƒœã‚¹æ­¦å™¨ã®ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆæ•°', bossWeapon.enchants.length, 2, 3);

        // ãƒœã‚¹é˜²å…·ç”Ÿæˆ
        const bossArmor = Equipment.generateBossArmor({
            baseName: 'ãƒ†ã‚¹ãƒˆé§', slot: 'body',
            baseDEF: 50, baseHP: 100, chance: 1.0,
            enchantSlots: { min: 1, max: 2 }
        }, 10);
        TestRunner.assert('ãƒœã‚¹é˜²å…·ãŒç”Ÿæˆã•ã‚ŒãŸ', !!bossArmor);
        TestRunner.assertEqual('ãƒœã‚¹é˜²å…·ã®ã‚¹ãƒ­ãƒƒãƒˆ', bossArmor.slot, 'body');
        TestRunner.assert('ãƒœã‚¹é˜²å…·ã®DEF > 0', bossArmor.def > 0);
        TestRunner.assert('ãƒœã‚¹é˜²å…·ã®HP > 0', bossArmor.hp > 0);

        // ãƒ©ãƒ³ãƒ€ãƒ è£…å‚™ç”Ÿæˆ
        const randEquip = Equipment.generateRandomEquipment(10);
        TestRunner.assert('ãƒ©ãƒ³ãƒ€ãƒ è£…å‚™ç”ŸæˆæˆåŠŸ', !!randEquip);
        TestRunner.assert('ãƒ©ãƒ³ãƒ€ãƒ è£…å‚™ã«ã‚¹ãƒ­ãƒƒãƒˆ', !!randEquip.slot);
        TestRunner.assert('ãƒ©ãƒ³ãƒ€ãƒ è£…å‚™ã«ãƒ¬ã‚¢ãƒªãƒ†ã‚£', !!randEquip.rarity);

        // è£…å‚™ã®ç€è„±
        resetGameState();
        const testWeapon = {
            uid: 'eq_test_1', name: 'ãƒ†ã‚¹ãƒˆåˆ€', slot: 'weapon', weaponType: 'katana',
            rarity: 'rare', atk: 100, def: 0, hp: 0, element: null,
            enchants: [], enhanceLevel: 0, fixedEffect: null
        };
        GameState.inventory.equipment.push(testWeapon);
        Equipment.equipItem(testWeapon);
        TestRunner.assert('è£…å‚™å¾Œã«æ­¦å™¨ã‚¹ãƒ­ãƒƒãƒˆã«å…¥ã‚‹', GameState.equipped.weapon !== null);
        TestRunner.assertEqual('è£…å‚™å¾Œã®æ­¦å™¨å', GameState.equipped.weapon.name, 'ãƒ†ã‚¹ãƒˆåˆ€');
        TestRunner.assertEqual('ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰é™¤å»', GameState.inventory.equipment.length, 0);

        Equipment.unequipItem('weapon');
        TestRunner.assertEqual('å¤–ã—ãŸå¾Œã®æ­¦å™¨ã‚¹ãƒ­ãƒƒãƒˆ', GameState.equipped.weapon, null);
        TestRunner.assertEqual('ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«æˆ»ã‚‹', GameState.inventory.equipment.length, 1);

        // è£…å‚™å…¥ã‚Œæ›¿ãˆ
        const weapon1 = { uid: 'w1', name: 'æ­¦å™¨1', slot: 'weapon', weaponType: 'katana', rarity: 'common', atk: 50, def: 0, hp: 0, element: null, enchants: [], enhanceLevel: 0, fixedEffect: null };
        const weapon2 = { uid: 'w2', name: 'æ­¦å™¨2', slot: 'weapon', weaponType: 'bow', rarity: 'rare', atk: 80, def: 0, hp: 0, element: 'fire', enchants: [], enhanceLevel: 0, fixedEffect: null };
        resetGameState();
        GameState.inventory.equipment.push(weapon1);
        GameState.inventory.equipment.push(weapon2);
        Equipment.equipItem(weapon1);
        Equipment.equipItem(weapon2);
        TestRunner.assertEqual('å…¥ã‚Œæ›¿ãˆå¾Œã®æ­¦å™¨', GameState.equipped.weapon.name, 'æ­¦å™¨2');
        TestRunner.assert('æ—§æ­¦å™¨ãŒã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«æˆ»ã‚‹', GameState.inventory.equipment.some(e => e.name === 'æ­¦å™¨1'));

        // ==========================================
        // 7. å¼ç¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('7. å¼ç¥ã‚·ã‚¹ãƒ†ãƒ ');

        resetGameState();

        // å¼ç¥å…¥æ‰‹
        Shikigami.obtainShikigami('kodama');
        TestRunner.assert('å¼ç¥å…¥æ‰‹æˆåŠŸ', !!GameState.shikigami.owned['kodama']);
        TestRunner.assertEqual('å¼ç¥ã®åˆæœŸãƒ¬ãƒ™ãƒ«', GameState.shikigami.owned['kodama'].level, 1);

        // å¼ç¥è¢«ã‚Š
        Shikigami.obtainShikigami('kodama');
        TestRunner.assert('è¢«ã‚Šæ™‚å¥½æ„Ÿåº¦å¢—åŠ ', GameState.shikigami.owned['kodama'].affection > 0);

        // ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆ
        Shikigami.addToParty('kodama');
        TestRunner.assertEqual('ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¹ãƒ­ãƒƒãƒˆ0ã«å¼ç¥', GameState.shikigami.party[0], 'kodama');

        // é‡è¤‡ç·¨æˆãƒã‚§ãƒƒã‚¯
        const partyBefore = [...GameState.shikigami.party];
        Shikigami.addToParty('kodama');
        TestRunner.assertEqual('é‡è¤‡ç·¨æˆã¯æ‹’å¦', GameState.shikigami.party[1], null);

        // çµŒé¨“å€¤ä»˜ä¸
        Shikigami.addExp('kodama', 999999);
        TestRunner.assert('å¼ç¥ãƒ¬ãƒ™ãƒ«ãŒä¸ŠãŒã‚‹', GameState.shikigami.owned['kodama'].level > 1);
        const maxLevel = SHIKIGAMI_DATA['kodama'].stars * 10;
        TestRunner.assert('å¼ç¥ãƒ¬ãƒ™ãƒ«ä¸Šé™ãƒã‚§ãƒƒã‚¯', GameState.shikigami.owned['kodama'].level <= maxLevel);

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‹ã‚‰å¤–ã™
        Shikigami.removeFromParty(0);
        TestRunner.assertEqual('ãƒ‘ãƒ¼ãƒ†ã‚£ã‹ã‚‰å¤–ã™æˆåŠŸ', GameState.shikigami.party[0], null);

        // ==========================================
        // 8. é›å†¶ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('8. é›å†¶ã‚·ã‚¹ãƒ†ãƒ ');

        resetGameState();

        // ã‚¯ãƒ©ãƒ•ãƒˆå¯èƒ½ãƒã‚§ãƒƒã‚¯ï¼ˆç´ æä¸è¶³ï¼‰
        const recipe = CRAFT_RECIPES['wooden_katana'];
        TestRunner.assert('ç´ æä¸è¶³ã§ã‚¯ãƒ©ãƒ•ãƒˆä¸å¯', !Smithy.canCraft(recipe));

        // ç´ æã‚’ç”¨æ„ã—ã¦ã‚¯ãƒ©ãƒ•ãƒˆ
        GameState.player.gold = 10000;
        GameState.inventory.materials['wood_shard'] = 10;
        GameState.inventory.materials['spirit_wood'] = 5;
        TestRunner.assert('ç´ æå……è¶³ã§ã‚¯ãƒ©ãƒ•ãƒˆå¯èƒ½', Smithy.canCraft(recipe));

        Smithy.craft('wooden_katana');
        TestRunner.assert('ã‚¯ãƒ©ãƒ•ãƒˆå¾Œã«ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«è¿½åŠ ', GameState.inventory.equipment.length === 1);
        TestRunner.assertEqual('ã‚¯ãƒ©ãƒ•ãƒˆå“ã®åå‰', GameState.inventory.equipment[0].name, 'æœ¨åˆ€');
        TestRunner.assert('ã‚´ãƒ¼ãƒ«ãƒ‰ãŒæ¸›å°‘', GameState.player.gold < 10000);
        TestRunner.assert('ç´ æãŒæ¶ˆè²»ã•ã‚ŒãŸ', GameState.inventory.materials['wood_shard'] < 10);
        TestRunner.assert('ã‚¯ãƒ©ãƒ•ãƒˆã‚«ã‚¦ãƒ³ãƒˆå¢—åŠ ', GameState.encyclopedia.craftCount >= 1);

        // å¼·åŒ–ãƒ†ã‚¹ãƒˆ
        const craftedItem = GameState.inventory.equipment[0];
        const atkBefore = craftedItem.atk;
        GameState.inventory.materials['enhance_stone'] = 100;
        GameState.player.gold = 100000;
        Smithy.enhance(craftedItem.uid);
        // å¼·åŒ–ã¯ç¢ºç‡ãªã®ã§æˆåŠŸ/å¤±æ•—ã©ã¡ã‚‰ã§ã‚‚OK
        TestRunner.assert('å¼·åŒ–å‡¦ç†ãŒå®Ÿè¡Œã•ã‚ŒãŸï¼ˆã‚¨ãƒ©ãƒ¼ãªã—ï¼‰', true);

        // åˆ†è§£ãƒ†ã‚¹ãƒˆ
        resetGameState();
        const dismantleItem = {
            uid: 'dis_test', name: 'åˆ†è§£ç”¨æ­¦å™¨', slot: 'weapon', weaponType: 'katana',
            rarity: 'rare', atk: 100, def: 0, hp: 0, element: null,
            enchants: [], enhanceLevel: 0, fixedEffect: null
        };
        GameState.inventory.equipment.push(dismantleItem);
        const goldBeforeDismantle = GameState.player.gold;
        Smithy.dismantle('dis_test');
        TestRunner.assert('åˆ†è§£å¾Œã‚´ãƒ¼ãƒ«ãƒ‰å¢—åŠ ', GameState.player.gold > goldBeforeDismantle);
        TestRunner.assertEqual('åˆ†è§£å¾Œã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰é™¤å»', GameState.inventory.equipment.length, 0);

        // ==========================================
        // 9. ã‚¬ãƒãƒ£ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('9. ã‚¬ãƒãƒ£ã‚·ã‚¹ãƒ†ãƒ ');

        resetGameState();

        // éœŠçŸ³ã‚¬ãƒãƒ£ï¼ˆã‚³ã‚¹ãƒˆä¸è¶³ï¼‰
        GameState.player.spiritStones = 5;
        const shikiCountBefore = Object.keys(GameState.shikigami.owned).length;
        Gacha.pullSpirit(1);
        TestRunner.assertEqual('éœŠçŸ³ä¸è¶³ã§ã‚¬ãƒãƒ£ä¸å¯', Object.keys(GameState.shikigami.owned).length, shikiCountBefore);

        // éœŠçŸ³ã‚¬ãƒãƒ£ï¼ˆã‚³ã‚¹ãƒˆå……è¶³ï¼‰
        GameState.player.spiritStones = 100;
        Gacha.pullSpirit(1);
        TestRunner.assertEqual('ã‚¬ãƒãƒ£å¾ŒéœŠçŸ³æ¸›å°‘', GameState.player.spiritStones, 90);
        TestRunner.assert('ã‚¬ãƒãƒ£å¾Œå¼ç¥ã‚’å…¥æ‰‹', Object.keys(GameState.shikigami.owned).length > 0);
        TestRunner.assert('å¤©äº•ã‚«ã‚¦ãƒ³ãƒˆå¢—åŠ ', GameState.gachaPity.spirit > 0);

        // å¤©äº•ãƒ†ã‚¹ãƒˆ
        resetGameState();
        GameState.player.spiritStones = 10000;
        GameState.gachaPity.spirit = GACHA_TABLE.spirit.pity - 1;
        Gacha.pullSpirit(1);
        // â˜…5ãŒå¤©äº•ã§ç¢ºå®šæ’å‡ºã•ã‚Œã‚‹ã¯ãš
        const has5star = Object.entries(GameState.shikigami.owned).some(([id]) => SHIKIGAMI_DATA[id]?.stars === 5);
        TestRunner.assert('å¤©äº•ã§â˜…5ç¢ºå®š', has5star);
        TestRunner.assertEqual('å¤©äº•å¾Œã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ', GameState.gachaPity.spirit, 0);

        // ã‚´ãƒ¼ãƒ«ãƒ‰ã‚¬ãƒãƒ£
        resetGameState();
        GameState.player.gold = 50000;
        const invBefore = GameState.inventory.equipment.length;
        Gacha.pullGold(1);
        TestRunner.assert('ã‚´ãƒ¼ãƒ«ãƒ‰ã‚¬ãƒãƒ£å¾Œã«ã‚´ãƒ¼ãƒ«ãƒ‰æ¸›å°‘', GameState.player.gold < 50000);

        // ==========================================
        // 10. é—˜æŠ€å ´ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('10. é—˜æŠ€å ´');

        resetGameState();

        // å¯¾æˆ¦ç›¸æ‰‹ç”Ÿæˆ
        const opponent = Arena.generateOpponent(500);
        TestRunner.assert('å¯¾æˆ¦ç›¸æ‰‹ç”ŸæˆæˆåŠŸ', !!opponent);
        TestRunner.assert('å¯¾æˆ¦ç›¸æ‰‹ã«ATK', opponent.atk > 0);
        TestRunner.assert('å¯¾æˆ¦ç›¸æ‰‹ã«HP', opponent.hp > 0);
        TestRunner.assert('å¯¾æˆ¦ç›¸æ‰‹ã«å±æ€§', !!opponent.element);

        // å¯¾æˆ¦
        const rankBefore = GameState.arena.rank;
        Arena.battle({ ...opponent, rank: rankBefore });
        const totalBattles = GameState.arena.wins + GameState.arena.losses;
        TestRunner.assertEqual('å¯¾æˆ¦å¾Œã«å‹æ•—ã‚«ã‚¦ãƒ³ãƒˆ+1', totalBattles, 1);

        // ãƒ¡ãƒ€ãƒ«äº¤æ›
        resetGameState();
        GameState.arena.medals = 100;
        Arena.exchangeMedals('spiritStones', 10, 50);
        TestRunner.assertEqual('ãƒ¡ãƒ€ãƒ«äº¤æ›å¾Œãƒ¡ãƒ€ãƒ«æ¸›å°‘', GameState.arena.medals, 50);
        TestRunner.assertEqual('éœŠçŸ³å¢—åŠ ', GameState.player.spiritStones, 60); // 50åˆæœŸ + 10

        // ==========================================
        // 11. ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('11. ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰');

        resetGameState();
        GameState.player.gold = 12345;
        GameState.player.spiritStones = 67;

        // ã‚»ãƒ¼ãƒ–
        const saveResult = Save.save();
        TestRunner.assert('ã‚»ãƒ¼ãƒ–æˆåŠŸ', saveResult === true);
        TestRunner.assert('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿å­˜åœ¨ç¢ºèª', Save.hasSave());

        // çŠ¶æ…‹å¤‰æ›´å¾Œã«ãƒ­ãƒ¼ãƒ‰
        GameState.player.gold = 0;
        GameState.player.spiritStones = 0;
        const loadResult = Save.load();
        TestRunner.assert('ãƒ­ãƒ¼ãƒ‰æˆåŠŸ', loadResult === true);
        TestRunner.assertEqual('ãƒ­ãƒ¼ãƒ‰å¾Œã®ã‚´ãƒ¼ãƒ«ãƒ‰å¾©å…ƒ', GameState.player.gold, 12345);
        TestRunner.assertEqual('ãƒ­ãƒ¼ãƒ‰å¾Œã®éœŠçŸ³å¾©å…ƒ', GameState.player.spiritStones, 67);

        // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        const exported = Save.exportSave();
        TestRunner.assert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæˆåŠŸ', exported.length > 0);
        GameState.player.gold = 0;
        const importResult = Save.importSave(exported);
        TestRunner.assert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ', importResult === true);
        TestRunner.assertEqual('ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¾Œã®ã‚´ãƒ¼ãƒ«ãƒ‰å¾©å…ƒ', GameState.player.gold, 12345);

        // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        Save.deleteSave();
        TestRunner.assert('ã‚»ãƒ¼ãƒ–å‰Šé™¤æˆåŠŸ', !Save.hasSave());

        // ==========================================
        // 12. å›³é‘‘ãƒ»å®Ÿç¸¾ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('12. å›³é‘‘ãƒ»å®Ÿç¸¾');

        resetGameState();

        // æ•µå›³é‘‘ç™»éŒ²
        GameState.encyclopedia.discoveredEnemies['forest_tanuki'] = true;
        TestRunner.assert('æ•µå›³é‘‘ç™»éŒ²', !!GameState.encyclopedia.discoveredEnemies['forest_tanuki']);

        // å®Ÿç¸¾ãƒã‚§ãƒƒã‚¯ - åˆã‚ã¦ã®è¨ä¼
        Encyclopedia.checkAllAchievements();
        TestRunner.assert('ã€Œåˆã‚ã¦ã®è¨ä¼ã€å®Ÿç¸¾é”æˆ', !!GameState.encyclopedia.achievements['first_kill']);

        // å®Ÿç¸¾å ±é…¬ï¼ˆéœŠçŸ³ï¼‰
        TestRunner.assert('å®Ÿç¸¾å ±é…¬ã®éœŠçŸ³å¢—åŠ ', GameState.player.spiritStones > 50);

        // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚¯ãƒªã‚¢å®Ÿç¸¾
        GameState.player.clearedDungeons['forest'] = true;
        Encyclopedia.checkAllAchievements();
        TestRunner.assert('ã€Œæ£®ã®å®ˆã‚Šæ‰‹ã€å®Ÿç¸¾é”æˆ', !!GameState.encyclopedia.achievements['clear_forest']);

        // å¼ç¥åé›†å®Ÿç¸¾
        Shikigami.obtainShikigami('kodama');
        Shikigami.obtainShikigami('hinotama_shiki');
        Shikigami.obtainShikigami('kappa_shiki');
        Encyclopedia.checkAllAchievements();
        TestRunner.assert('ã€Œå¼ç¥ä½¿ã„ã€å®Ÿç¸¾é”æˆ', !!GameState.encyclopedia.achievements['shikigami_3']);

        // ==========================================
        // 13. æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('13. æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ ');

        // å„æ­¦å™¨ã‚¿ã‚¤ãƒ—ã®åˆæœŸåŒ–
        for (const type of Object.keys(WEAPON_TYPES)) {
            try {
                Weapons.init(type);
                TestRunner.assert(`æ­¦å™¨[${type}] åˆæœŸåŒ–æˆåŠŸ`, true);
            } catch (e) {
                TestRunner.assert(`æ­¦å™¨[${type}] åˆæœŸåŒ–æˆåŠŸ`, false, e.message);
            }
        }

        // åˆ€ã‚³ãƒ³ãƒœ
        Weapons.init('katana');
        TestRunner.assert('åˆ€ã®åˆæœŸã‚³ãƒ³ãƒœ = 0', Weapons.state.comboCount === 0);

        // å¼“ãƒãƒ£ãƒ¼ã‚¸
        Weapons.init('bow');
        TestRunner.assert('å¼“ã®åˆæœŸãƒãƒ£ãƒ¼ã‚¸çŠ¶æ…‹ = false', Weapons.state.charging === false);

        // æ§ã‚¿ã‚¤ãƒŸãƒ³ã‚°
        Weapons.init('spear');
        TestRunner.assert('æ§ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®åˆæœŸåŒ–', Weapons.state.cursorPos === 0);

        // æ‹³é€£æ‰“
        Weapons.init('fist');
        TestRunner.assert('æ‹³ã®ã‚¯ãƒªãƒƒã‚¯é…åˆ—åˆæœŸåŒ–', Array.isArray(Weapons.state.clicks));

        // æ–ãƒ‘ã‚¿ãƒ¼ãƒ³
        Weapons.init('staff');
        TestRunner.assert('æ–ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ', Weapons.state.pattern && Weapons.state.pattern.length > 0);

        // å¤§æ§Œã‚²ãƒ¼ã‚¸
        Weapons.init('hammer');
        TestRunner.assertEqual('å¤§æ§Œã‚²ãƒ¼ã‚¸åˆæœŸå€¤', Weapons.state.gauge, 0);

        // ==========================================
        // 14. ã‚µã‚¦ãƒ³ãƒ‰ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('14. ã‚µã‚¦ãƒ³ãƒ‰ã‚·ã‚¹ãƒ†ãƒ ');

        GameState.settings.soundEnabled = false;
        try {
            SoundManager.hit();
            SoundManager.crit();
            SoundManager.enemyDefeat();
            SoundManager.bossAppear();
            SoundManager.levelUp();
            SoundManager.heal();
            SoundManager.playerHit();
            SoundManager.playerDeath();
            SoundManager.gachaPull();
            SoundManager.gachaRare();
            TestRunner.assert('ã‚µã‚¦ãƒ³ãƒ‰é–¢æ•°ï¼ˆç„¡åŠ¹æ™‚ï¼‰å…¨ã¦å‘¼ã³å‡ºã—æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('ã‚µã‚¦ãƒ³ãƒ‰é–¢æ•°ï¼ˆç„¡åŠ¹æ™‚ï¼‰å…¨ã¦å‘¼ã³å‡ºã—æˆåŠŸ', false, e.message);
        }

        // ==========================================
        // 15. UIæç”»ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('15. UIæç”»');

        resetGameState();
        GameState.dungeon.active = true;
        GameState.dungeon.currentDungeon = 'forest';
        GameState.dungeon.playerHP = 100;
        GameState.dungeon.playerMaxHP = 100;
        GameState.dungeon.playerMP = 50;
        GameState.dungeon.playerMaxMP = 50;
        GameState.dungeon.playerLevel = 5;
        GameState.dungeon.playerExp = 50;
        GameState.dungeon.killCount = 3;
        GameState.dungeon.killsRequired = 5;

        try {
            UI.updatePlayerBars();
            TestRunner.assert('UI.updatePlayerBars() æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('UI.updatePlayerBars() æˆåŠŸ', false, e.message);
        }

        try {
            UI.updatePlayerStats();
            TestRunner.assert('UI.updatePlayerStats() æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('UI.updatePlayerStats() æˆåŠŸ', false, e.message);
        }

        try {
            UI.updateKillCounter();
            TestRunner.assert('UI.updateKillCounter() æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('UI.updateKillCounter() æˆåŠŸ', false, e.message);
        }

        try {
            UI.updateAcquiredSkills();
            TestRunner.assert('UI.updateAcquiredSkills() æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('UI.updateAcquiredSkills() æˆåŠŸ', false, e.message);
        }

        try {
            UI.updateVillageSummary();
            TestRunner.assert('UI.updateVillageSummary() æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('UI.updateVillageSummary() æˆåŠŸ', false, e.message);
        }

        // æ•µè¡¨ç¤º
        GameState.dungeon.currentEnemies = [{
            id: 'test', name: 'ãƒ†ã‚¹ãƒˆ', emoji: 'ğŸ‘»', element: 'fire',
            hp: 100, maxHP: 100, atk: 10, def: 5, position: 1, isBoss: false
        }];
        try {
            UI.updateEnemyDisplay();
            TestRunner.assert('UI.updateEnemyDisplay() æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('UI.updateEnemyDisplay() æˆåŠŸ', false, e.message);
        }

        // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªè¡¨ç¤º
        try {
            UI.renderInventory('equip');
            TestRunner.assert('UI.renderInventory("equip") æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('UI.renderInventory("equip") æˆåŠŸ', false, e.message);
        }

        try {
            UI.renderInventory('materials');
            TestRunner.assert('UI.renderInventory("materials") æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('UI.renderInventory("materials") æˆåŠŸ', false, e.message);
        }

        // ==========================================
        // 16. ç”»é¢é·ç§»ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('16. ç”»é¢é·ç§»');

        try {
            switchScreen('village');
            TestRunner.assertEqual('æ‘ç”»é¢ã«é·ç§»', GameState.screen, 'village');
            switchScreen('battle');
            TestRunner.assertEqual('æˆ¦é—˜ç”»é¢ã«é·ç§»', GameState.screen, 'battle');
            switchScreen('smithy');
            TestRunner.assertEqual('é›å†¶ç”»é¢ã«é·ç§»', GameState.screen, 'smithy');
        } catch (e) {
            TestRunner.assert('ç”»é¢é·ç§»æˆåŠŸ', false, e.message);
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«
        try {
            openModal('levelup-modal');
            TestRunner.assert('ãƒ¢ãƒ¼ãƒ€ãƒ«é–‹ãæˆåŠŸ', document.getElementById('levelup-modal').classList.contains('active'));
            closeModal('levelup-modal');
            TestRunner.assert('ãƒ¢ãƒ¼ãƒ€ãƒ«é–‰ã˜ã‚‹æˆåŠŸ', !document.getElementById('levelup-modal').classList.contains('active'));
        } catch (e) {
            TestRunner.assert('ãƒ¢ãƒ¼ãƒ€ãƒ«æ“ä½œæˆåŠŸ', false, e.message);
        }

        // ==========================================
        // 17. é›å†¶ç”»é¢æç”»ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('17. é›å†¶ç”»é¢æç”»');

        resetGameState();
        try {
            Smithy.currentTab = 'craft';
            Smithy.render();
            TestRunner.assert('é›å†¶:ä½œæˆã‚¿ãƒ–æç”»æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('é›å†¶:ä½œæˆã‚¿ãƒ–æç”»æˆåŠŸ', false, e.message);
        }

        try {
            Smithy.currentTab = 'enhance';
            Smithy.render();
            TestRunner.assert('é›å†¶:å¼·åŒ–ã‚¿ãƒ–æç”»æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('é›å†¶:å¼·åŒ–ã‚¿ãƒ–æç”»æˆåŠŸ', false, e.message);
        }

        try {
            Smithy.currentTab = 'reforge';
            Smithy.render();
            TestRunner.assert('é›å†¶:éŒ¬æˆã‚¿ãƒ–æç”»æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('é›å†¶:éŒ¬æˆã‚¿ãƒ–æç”»æˆåŠŸ', false, e.message);
        }

        try {
            Smithy.currentTab = 'dismantle';
            Smithy.render();
            TestRunner.assert('é›å†¶:åˆ†è§£ã‚¿ãƒ–æç”»æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('é›å†¶:åˆ†è§£ã‚¿ãƒ–æç”»æˆåŠŸ', false, e.message);
        }

        // ==========================================
        // 18. å›³é‘‘ç”»é¢æç”»ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('18. å›³é‘‘ç”»é¢æç”»');

        resetGameState();
        GameState.encyclopedia.discoveredEnemies['forest_tanuki'] = true;
        Shikigami.obtainShikigami('kodama');
        GameState.inventory.materials['wood_shard'] = 5;

        try {
            Encyclopedia.currentTab = 'enemies';
            Encyclopedia.renderTab();
            TestRunner.assert('å›³é‘‘:å¦–æ€ªã‚¿ãƒ–æç”»æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('å›³é‘‘:å¦–æ€ªã‚¿ãƒ–æç”»æˆåŠŸ', false, e.message);
        }

        try {
            Encyclopedia.currentTab = 'bosses';
            Encyclopedia.renderTab();
            TestRunner.assert('å›³é‘‘:ãƒœã‚¹ã‚¿ãƒ–æç”»æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('å›³é‘‘:ãƒœã‚¹ã‚¿ãƒ–æç”»æˆåŠŸ', false, e.message);
        }

        try {
            Encyclopedia.currentTab = 'shikigami';
            Encyclopedia.renderTab();
            TestRunner.assert('å›³é‘‘:å¼ç¥ã‚¿ãƒ–æç”»æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('å›³é‘‘:å¼ç¥ã‚¿ãƒ–æç”»æˆåŠŸ', false, e.message);
        }

        try {
            Encyclopedia.currentTab = 'equipment';
            Encyclopedia.renderTab();
            TestRunner.assert('å›³é‘‘:è£…å‚™ã‚¿ãƒ–æç”»æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('å›³é‘‘:è£…å‚™ã‚¿ãƒ–æç”»æˆåŠŸ', false, e.message);
        }

        try {
            Encyclopedia.currentTab = 'materials';
            Encyclopedia.renderTab();
            TestRunner.assert('å›³é‘‘:ç´ æã‚¿ãƒ–æç”»æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('å›³é‘‘:ç´ æã‚¿ãƒ–æç”»æˆåŠŸ', false, e.message);
        }

        try {
            Encyclopedia.currentTab = 'achievements';
            Encyclopedia.renderTab();
            TestRunner.assert('å›³é‘‘:å®Ÿç¸¾ã‚¿ãƒ–æç”»æˆåŠŸ', true);
        } catch (e) {
            TestRunner.assert('å›³é‘‘:å®Ÿç¸¾ã‚¿ãƒ–æç”»æˆåŠŸ', false, e.message);
        }

        // ==========================================
        // 19. ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ
        // ==========================================
        TestRunner.group('19. ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹');

        // å€‰åº«ä¸Šé™ãƒ†ã‚¹ãƒˆ
        resetGameState();
        GameState.inventory.maxEquipSlots = 2;
        GameState.inventory.equipment.push({ uid: 'e1', name: 'è£…å‚™1', slot: 'head', rarity: 'common', enchants: [] });
        GameState.inventory.equipment.push({ uid: 'e2', name: 'è£…å‚™2', slot: 'body', rarity: 'common', enchants: [] });
        const equipped3 = { uid: 'e3', name: 'è£…å‚™3', slot: 'feet', rarity: 'common', atk: 0, def: 10, hp: 0, element: null, enchants: [], enhanceLevel: 0, fixedEffect: null };
        GameState.equipped.feet = equipped3;
        Equipment.unequipItem('feet');
        TestRunner.assert('å€‰åº«ãŒã„ã£ã±ã„ã®æ™‚ã¯å¤–ã›ãªã„', GameState.equipped.feet !== null);

        // ã‚´ãƒ¼ãƒ«ãƒ‰0ã§ã®ã‚¯ãƒ©ãƒ•ãƒˆ
        resetGameState();
        GameState.player.gold = 0;
        TestRunner.assert('ã‚´ãƒ¼ãƒ«ãƒ‰0ã§ã‚¯ãƒ©ãƒ•ãƒˆä¸å¯', !Smithy.canCraft(CRAFT_RECIPES['wooden_katana']));

        // ç©ºã®å¼ç¥ãƒ‘ãƒ¼ãƒ†ã‚£ã§ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¨ˆç®—
        resetGameState();
        GameState.shikigami.party = [null, null, null];
        try {
            const emptyPartyStats = calculatePlayerStats();
            TestRunner.assert('ç©ºãƒ‘ãƒ¼ãƒ†ã‚£ã§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¨ˆç®—æˆåŠŸ', emptyPartyStats.atk > 0);
        } catch (e) {
            TestRunner.assert('ç©ºãƒ‘ãƒ¼ãƒ†ã‚£ã§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¨ˆç®—æˆåŠŸ', false, e.message);
        }

        // ç”Ÿå­˜æ•µ0ã§ã®æ“ä½œ
        resetGameState();
        GameState.dungeon.active = true;
        GameState.dungeon.currentEnemies = [];
        try {
            Combat.performClick(1.0);
            TestRunner.assert('æ•µ0ä½“ã§ã‚¯ãƒªãƒƒã‚¯æ”»æ’ƒãŒã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„', true);
        } catch (e) {
            TestRunner.assert('æ•µ0ä½“ã§ã‚¯ãƒªãƒƒã‚¯æ”»æ’ƒãŒã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„', false, e.message);
        }

        // ==========================================
        // 20. ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³è§£æ”¾ãƒã‚§ãƒ¼ãƒ³
        // ==========================================
        TestRunner.group('20. ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³è§£æ”¾ãƒã‚§ãƒ¼ãƒ³');

        resetGameState();
        const dungeonOrder = ['forest', 'shrine', 'cave', 'sea', 'thunder', 'dark', 'infinite'];

        TestRunner.assert('åˆæœŸ: forestã®ã¿ã‚¢ãƒ³ãƒ­ãƒƒã‚¯', Dungeon.isDungeonUnlocked('forest'));
        for (let i = 1; i < dungeonOrder.length; i++) {
            TestRunner.assert(`åˆæœŸ: ${dungeonOrder[i]}ã¯ãƒ­ãƒƒã‚¯`, !Dungeon.isDungeonUnlocked(dungeonOrder[i]));
        }

        // é †ç•ªã«ã‚¯ãƒªã‚¢ã—ã¦ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ç¢ºèª
        for (let i = 0; i < dungeonOrder.length - 1; i++) {
            GameState.player.clearedDungeons[dungeonOrder[i]] = true;
            TestRunner.assert(`${dungeonOrder[i]}ã‚¯ãƒªã‚¢å¾Œ: ${dungeonOrder[i+1]}ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯`,
                Dungeon.isDungeonUnlocked(dungeonOrder[i+1])
            );
        }

        // ===== çµæœè¡¨ç¤º =====
        TestRunner.render();

        // çŠ¶æ…‹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        resetGameState();
        Save.deleteSave();
    }

    // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    runAllTests();
    </script>
</body>
</html>
